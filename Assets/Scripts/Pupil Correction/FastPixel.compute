/*
 * Assuming D65 white point:
 * 
 * X: 0.4124564  0.3575761  0.1804375
 * Y: 0.2126729  0.7151522  0.0721750
 * Z: 0.0193339  0.1191920  0.9503041
 */
float3 get_linear_to_xyz(const float3 color)
{
    return float3(
        dot(color, float3(0.4124564, 0.3575761, 0.1804375)),
        dot(color, float3(0.2126729, 0.7151522, 0.0721750)),
        dot(color, float3(0.0193339, 0.1191920, 0.9503041))
    );
}

#pragma kernel linear_to_xyz
#define GROUP_SIZE 8

RWTexture2D<float4> linear_source;
RWStructuredBuffer<float> luminance;
uint2 source_size;

groupshared float shared_average[GROUP_SIZE*GROUP_SIZE];
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void linear_to_xyz(uint3 globalId : SV_DispatchThreadID, uint3 localId : SV_GroupThreadID, uint3 groupId : SV_GroupID)
{
    if (globalId.x >= source_size.x || globalId.y >= source_size.y)
    {
        return;
    }

    // Color value is already in Linear space, can skip conversion from sRGB
    // (HDR processing occurs with sRGB values in linear space)
    const float4 color = linear_source[globalId.xy];
    const float4 xyz = float4(0.0, 1.0, 0.0, 1.0);//get_linear_to_xyz(color);
    luminance[0] = 0.123456;

    // uint flattened_index = localId.y * GROUP_SIZE + localId.x;
    // GroupMemoryBarrier();
    // shared_average[flattened_index] = xyz.y;
    //
    // [unroll]
    // for (uint stride = GROUP_SIZE / 2; stride > 0; stride >>= 1)
    // {
    //     if(globalId.x < stride)
    //     {
    //         shared_average[flattened_index] += shared_average[flattened_index + stride] ;
    //     }
    //     GroupMemoryBarrier();
    // }
    // GroupMemoryBarrier();
    //
    // if (localId.x == 0 && localId.y == 0)
    // {
    //     luminance[0] = 0.123456;
    // }
}

#pragma kernel read_luminance
Texture2D<float3> mip_source;


[numthreads(1,1,1)]
void read_luminance(uint3 globalId : SV_DispatchThreadID)
{
    //const float3 color = mip_source[uint2(0,0)];
    //luminance[0] = color.y;
}